---------수업Day3(22.10.31)----------------------------------------------------------------------------------------------
---------DB수업자료/[오라클] 무결성 제약 조건----------------------------------------------------------------------------------------------
-- 1. NOT NULL 제약조건
CREATE TABLE EMP01(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4)
);
--
INSERT INTO EMP01
VALUES(NULL,NULL,'SALESMAN',30);
--
SELECT * FROM EMP01;
--NOT NULL 구문
DROP TABLE EMP01 PURGE; -- emp01 삭제
CREATE TABLE EMP01(
    EMPNO NUMBER(4) NOT NULL,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4)
);
--
--INSERT INTO emp01
--VALUES(null,null,'salesman',30); -- not null로 생성하였기 때문에 null값 비허용
--
INSERT INTO EMP01
VALUES(7499,'allen','salesman',30);
--
SELECT*FROM EMP01;
-- 2. UNIQUE 제약조건 /이란 특정 칼럼에 대해 자료가 중복되지 않게 하는 것이다.
DROP TABLE EMP02;
CREATE TABLE EMP02(
    EMPNO NUMBER(4) UNIQUE,
    ename VARCHAR(10) NOT NULL,
    job VARCHAR2(9),
    deptno NUMBER(4)
);
--
INSERT INTO EMP02(empno, ename, job, deptno)
VALUES(7499, 'allen', 'salesman', 30);
--
--INSERT INTO emp02(empno, ename, job, deptno)
--VALUES(7499, 'allen', 'salesman', 30);
--7499는 UNIQUE로 생성되었기 때문에 무결성 제약 조건에 위배됩니다. 라는 오류가 발생한다.
INSERT INTO EMP02(empno, ename, job, deptno)
VALUES(NULL, 'jones', 'manager', 20);
--
INSERT INTO EMP02(empno, ename, job, deptno)
VALUES(NULL, 'jones', 'salesman', 10); -- null은 무결성 제약 조건에 위배되지 않는다.
SELECT * FROM EMP02;
--3. 데이터 딕셔너리 / 데이터베이스 자원을 효율적으로 관리하기 위한 다양한 정보를 저장하는 시스템 테이블을
-- 데이터 딕셔너리라고 한다.
SELECT table_name FROM user_tables
ORDER BY table_name DESC; --HR 사용자가 생성한 테이블의 이름을 조회한다.
--4. 제약조건 확인하기
SELECT constraint_name, constraint_type, table_name
FROM user_constraints
WHERE table_name = 'EMP02';
--
SELECT owner, constraint_name, table_name, column_name FROM user_cons_columns
WHERE table_name = 'EMP02';
--5. 데이터의 구분을 위한 PRIMARY KEY 제약조건
DROP TABLE EMP03;
CREATE TABLE EMP03(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    job VARCHAR(9),
    petino NUMBER(4)
);
--
INSERT INTO EMP03
VALUES(7499,'allen','salesman',30);
--
SELECT * FROM EMP03;
--
--INSERT INTO EMP03
--VALUES(7499,'jones','manager',20); --무결성 제약 조건 위배
--
--INSERT INTO EMP03
--VALUES(null,'jones','manager',20); -- null 값 삽입 불가
SELECT constraint_name, constraint_type, table_name
FROM user_constraints
WHERE table_name = 'EMP03';
--6. 참조 무결성을 위한 FOREIGN KEY 제약 조건
CREATE TABLE DEPT01(
    DEPTNO NUMBER(2) PRIMARY KEY,
    DNAME VARCHAR2(14) NOT NULL,
    LOC VARCHAR2(13)
);
INSERT INTO DEPT01 (DEPTNO,DNAME,LOC)VALUES(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT01 (DEPTNO,DNAME,LOC)VALUES(20,'RESEARCH','DALLAS');
INSERT INTO DEPT01 (DEPTNO,DNAME,LOC)VALUES(30,'SALES','CHICAGO');
INSERT INTO DEPT01 (DEPTNO,DNAME,LOC)VALUES(40,'OPERATIONS','BOSTON');
-- 외래 키 제약 조건에 지정하지 않은 EMP03테이블에 부서 테이블에 존재하지 않은 50번 부서번호 저장
INSERT INTO EMP03
VALUES(7566,'JONES','MANAGER',50);
SELECT * FROM EMP03;
SELECT * FROM DEPT01;
--외래키 설정
CREATE TABLE EMP04(
    EMPNO NUMBER(2) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2) REFERENCES DEPT01(DEPTNO)
);
ALTER TABLE EMP04 MODIFY EMPNO NUMBER(4);--내가 EMPNO NUMBER4를 2로 오타쳐서 수정해야됐음
--
INSERT INTO EMP04
VALUES(7499,'ALLEN','SALESMAN',30);
SELECT*FROM EMP04;
--
INSERT INTO EMP04
VALUES(7566,'JONES','MANAGER',50); --50일 때에는 50번이 존재하지 않기 때문에 사원정보가 추가 안되고 오류 발생
INSERT INTO EMP04
VALUES(7566,'JONES','MANAGER',30);
--
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP04';
--7. CHECK 제약 조건 / 입력되는 값을 체크하여 설정된 값 이외의 값이 들어오면 오류 메시지와 함께
-- 명령이 수행되지 못하게 되는 것 이다.
CREATE TABLE EMP05(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    GENDER VARCHAR2(1) CHECK (GENDER IN('M','F'))
);
--
INSERT INTO EMP05(EMPNO, ENAME,GENDER)
VALUES(7566, 'JONES', 'M');
SELECT * FROM EMP05;
--
--INSERT INTO EMP05(EMPNO, ENAME, GENDER) VALUES(7566,'JONES','A');
--체크 제약조건에 위배되었습니다. 오류 발생
DROP TABLE EMP06 PURGE; -- emp06 삭제
--5-2. 제약 조건명 지정하기
CREATE TABLE EMP06(
    EMPNO NUMBER(4) CONSTRAINT EMP06_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT EMP06_ENAME_NN NOT NULL,
    JOB VARCHAR2(9) CONSTRAINT EMP06_JOB_UK UNIQUE,
    DEPTNO NUMBER(2) CONSTRAINT EMP06_DEPTNO_FK REFERENCES DEPT01(DEPTNO)
);
--
INSERT INTO EMP06
VALUES(7499,'ALLEN','SALESMAN',30);
SELECT*FROM EMP06;
SELECT*FROM DEPT01;
--
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS WHERE TABLE_NAME='EMP06';
--
INSERT INTO EMP06 VALUES(7499,'ALLEN','SALESMAN',30);
--위에서 같은 문장을 선언했는데 기본키 값인7499가 중복허용이 안되고 고유키인 SALESMAN도 중복허용 안됨.
SELECT * FROM DEPT01;
INSERT INTO EMP06 VALUES(7499,NULL,'SALESMAN',50);
--ENAME열은 NOT NULL 제약사항이 걸려있다.
INSERT INTO EMP06 VALUES(7499,'ALLEN','SALESMAN',50);
--부모 키인 DEPT에 50은 없다. 얘가 참조 열이기 때문에 범위에 포함 되어야함
INSERT INTO EMP06 VALUES(7500,'ALLEN','SALESMAN',50);
INSERT INTO EMP06 VALUES(7500,'ALLEN','MANAGER',50);
--50만 범위에 들어오면 OK
--내 TEST
CREATE TABLE JB01(
    EMPNO NUMBER(4) CONSTRAINT JB01_EMPNO_PK PRIMARY KEY,
    ENAME VARCHAR2(10) CONSTRAINT JB01_ENAME_NN NOT NULL,
    JOB VARCHAR2(9) CONSTRAINT JB01_JOB_UK UNIQUE,
    EYE NUMBER(1) CONSTRAINT JB01_EYE_UK UNIQUE,
    --NOSE NUMBER(1) CONSTRAINT JB01_NOSE_UK PRIMARY KEY, -- 하나의 기본키만 가질 수 있으므로 오류
    DEPTNO NUMBER(2) CONSTRAINT JB01_DEPTNO_FK REFERENCES DEPT01(DEPTNO)
);
--3.테이블 레벨 정의 방식의 기본 형식
--컬럼 레벨로 제약 조건을 지정하는 방식
CREATE TABLE EMP07(
    EMPNO NUMBER(4) PRIMARY KEY,
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9) UNIQUE,
    DEPTNO NUMBER(2) REFERENCES DEPT01(DEPTNO)
);
--테이블 레벨로 제약 조건을 지정하는 방식
CREATE TABLE EMP08(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2),
    PRIMARY KEY(EMPNO),
    UNIQUE(JOB),
    FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO)
);
--제약 조건 확인
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP08';
--4.제약조건 변경하기
CREATE TABLE EMP09(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10),
    JOB VARCHAR2(9),
    DEPTNO NUMBER(4)
);
--제약 조건 변경하기
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP09';
-- EMP09 테이블의 EMPNO 칼럼에 기본키를 설정하고 DEPTNO 칼럼에 외래키를 설정한다.
ALTER TABLE EMP09
ADD PRIMARY KEY(EMPNO);
--
ALTER TABLE EMP09
ADD CONSTRAINT EMP09_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT01(DEPTNO);
--
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP09';
--제약 조건 제거하기
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP06';
--
SELECT * FROM EMP06;
--INSERT INTO EMP06
--VALUES(7499,'ALLEN','MANAGER',50);
--
ALTER TABLE EMP06
DROP CONSTRAINT EMP06_EMPNO_PK;
--
ALTER TABLE EMP06
DROP CONSTRAINT EMP06_DEPTNO_FK;
--5.외래키가 설정된 데이터 삭제
CREATE TABLE DEPT02(
    DEPTNO NUMBER(2),
    DNAME VARCHAR2(14),
    LOC VARCHAR2(13),
    CONSTRAINT DEPT02_DEPTNO_PK PRIMARY KEY(DEPTNO)
);
--
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'DEPT02';
--
INSERT INTO DEPT02 VALUES(10,'ACCOUNTING','NEW YORK');
INSERT INTO DEPT02 VALUES(20,'RESEARCH', 'DALLAS');

SELECT * FROM DEPT02;

DROP TABLE EMP02;

CREATE TABLE EMP02(
    EMPNO NUMBER(4),
    ENAME VARCHAR2(10) NOT NULL,
    JOB VARCHAR2(9),
    DEPTNO NUMBER(2),
    CONSTRAINT EMP02_EMPNO_PK PRIMARY KEY(EMPNO),
    CONSTRAINT EMP02_DEPTNO_FK FOREIGN KEY(DEPTNO) REFERENCES DEPT02(DEPTNO)
);
SELECT CONSTRAINT_NAME, CONSTRAINT_TYPE, TABLE_NAME, R_CONSTRAINT_NAME
FROM USER_CONSTRAINTS
WHERE TABLE_NAME = 'EMP02';
--
INSERT INTO EMP02 VALUES(7499,'ALLEN','SALESMAN',10);
INSERT INTO EMP02 VALUES(7369,'SMITH','CLERK',20);
SELECT * FROM EMP02;
--
CREATE TABLE TREATEMENT(
    T_NO NUMBER(4) NOT NULL,
    T_COURSE_ABBR VARCHAR2(3) NOT NULL,
    T_COURSE VARCHAR2(30) NOT NULL,
    T_TEL VARCHAR2(15) NOT NULL,
    CONSTRAINT TREATMENT_NO_PK PRIMARY KEY(T_NO),
    CONSTRAINT TREATMENT_COURSE_ABBR_UK UNIQUE(T_COURSE_ABBR)
);
INSERT INTO TREATMENT(T_NO, T_COURSE_ABBR, T_COURSE, T_TEL)
VALUES(1001, 'NS', '신경외과', '02-3452-1009');
INSERT INTO TREATMENT(T_NO, T_COURSE_ABBR, T_COURSE, T_TEL)
VALUES(1002, 'OS', '정형외과', '02-3452-2009');
INSERT INTO TREATMENT(T_NO, T_COURSE_ABBR, T_COURSE, T_TEL)
VALUES(1003, 'C', '순환기내과', '02-3452-3009');

SELECT * FROM TREATMENT;

CREATE TABLE DOCTOR(
    D_NO NUMBER(4) NOT NULL,
    D_NAME VARCHAR2(20) NOT NULL,
    D_SSN CHAR(14) NOT NULL,
    D_EMAIL VARCHAR2(80) NOT NULL,
    D_MAJOR VARCHAR2(50) NOT NULL,
    T_NO NUMBER(4),
    CONSTRAINT DOCTOR_D_NO_PK PRIMARY KEY(D_NO)
);
ALTER TABLE DOCTOR
ADD CONSTRAINT DOCTOR_T_NO FOREIGN KEY(T_NO) REFERENCES TREATMENT(T_NO)
ON DELETE CASCADE;

INSERT INTO DOCTOR(D_NO, D_NAME, D_SSN, D_EMAIL, D_MAJOR, T_NO)
VALUES(1, '홍길동', '660606-1234561', 'javauser@naver.com', '척추신경외과',1001);
INSERT INTO DOCTOR(D_NO, D_NAME, D_SSN, D_EMAIL, D_MAJOR, T_NO)
VALUES(2, '이재환', '690724-1674536', 'jaehwan@naver.com', '뇌졸중,뇌혈관외과',1003);
INSERT INTO DOCTOR(D_NO, D_NAME, D_SSN, D_EMAIL, D_MAJOR, T_NO)
VALUES(3, '양익환', '700129-1328962', 'sheep1209@naver.com', '인공관절,관절염',1002);
INSERT INTO DOCTOR(D_NO, D_NAME, D_SSN, D_EMAIL, D_MAJOR, T_NO)
VALUES(4, '김승현', '720901-1348940', 'seunghyeon@naver.com', '종양외과,외상전문',1002);

SELECT * FROM DOCTOR;