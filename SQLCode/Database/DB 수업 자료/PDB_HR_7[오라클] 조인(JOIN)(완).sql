--2022-11-04
--[오라클] 조인(JOIN)
--1) Cartesian Product (카티션 곱) 또는 Cross Join
-- Cross Join 이란 2개 이상의 테이블이 조인될 때 Where절에 의해 공통되는 칼럼에 의해 결합이 발생
-- 되지 않은 경우를 말한다. 그렇기 때문에 테이블에 존재하는 모든 데이터가 검색 결과로 나타난다.
--다음은 CROSS JOIN 으로 특별한 키워드 없이 SELECT문의 FROM절에 EMPLOYEES테이블과 DEPARTMENTS
--테이블을 동시에 기술한다.
SELECT * FROM EMPLOYEES, DEPARTMENTS;
--2)Equi Join (inner join)/가장 많이 사용되는 조인 방법으로서 조인 대상이 되는 두 테이블에서 공통
--적으로 존재하는 칼럼의 값이 일치되는 행을 연결하여 결과를 생성하는 조인 방법이다.
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMPLOYEES;
SELECT DEPARTMENT_ID, DEPARTMENT_NAME
FROM DEPARTMENTS;
--
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
-- 내가 그냥쓴거
SELECT EMPLOYEE_ID,FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES, DEPARTMENTS
WHERE EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
ORDER BY EMPLOYEE_ID;
--별칭
SELECT E.FIRST_NAME, D.DEPARTMENT_NAME, E.DEPARTMENT_ID
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--AND 연산 / Susan인 직원의 정보만을 출력하기 위해
SELECT E.FIRST_NAME, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID AND E.FIRST_NAME = 'Susan';
--강사님<문제>1. 학번, 학생명과 학과번호, 학과명을 출력하도록 쿼리문 작성해 주세요.
--학과번호 S_NUM 학과번호(학과 S_NAME 학과명(학과, SD_NUM 학번(학생, SD_NAME학생명(학생)
SELECT S.SD_NUM 학번, S.SD_NAME 학생명, E.S_NUM 학과번호, E.S_NAME 학과명
FROM SUBJECT E, STUDENT S
WHERE E.S_NUM = S.S_NUM;

--3)Non-Equi Join / 조인할 테이블 사이에 칼럼의 값이 직접적으로 일치하지 않을 시 사용하는
--조인으로 '='을 제외한 연산자를 사용한다. 
CREATE TABLE SALARYGRADE(
    GRADE NUMBER,
    MINSALARY NUMBER,
    MAXSALARY NUMBER
);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(1,2000,3000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(2,3001,4500);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(3,4501,6000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(4,6001,8000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(5,8001,10000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(6,10001,13000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(7,13001,20000);
INSERT INTO SALARYGRADE (GRADE, MINSALARY, MAXSALARY) VALUES(8,20001,30000);

COMMIT;
--
SELECT * FROM SALARYGRADE;
--
SELECT E.FIRST_NAME, E.SALARY, S.GRADE
FROM EMPLOYEES E, SALARYGRADE S
WHERE E.SALARY BETWEEN S.MINSALARY AND S.MAXSALARY;

SELECT E.FIRST_NAME, E.SALARY, S.GRADE
FROM EMPLOYEES E, SALARYGRADE S
WHERE E.SALARY >= S.MINSALARY AND E.SALARY <= S.MAXSALARY;
--4)Outer Join / 행이 조인 조건에 만족하지 않을 경우 그 행은 결과에 나타나지 않게 된다. 이 때 
--조인 조건에 만족하지 않는 행들도 나타내기 위해 Outer Join이 사용된다.
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY D.DEPARTMENT_ID;
--
SELECT * FROM DEPARTMENTS;
--
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID(+) = D.DEPARTMENT_ID;
--
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, DEPARTMENT_ID
FROM EMPLOYEES
WHERE HIRE_DATE >= '2007/01/01' AND HIRE_DATE <= '2007/06/30';
--
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID
AND HIRE_DATE >= '2007/01/01' AND HIRE_DATE <= '2007/06/30';
--
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE, D.DEPARTMENT_NAME
FROM EMPLOYEES E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID(+)
AND HIRE_DATE >= '2007/01/01' AND HIRE_DATE <= '2007/06/30';

--5)Self Join / 말 그대로 자기 자신과 조인을 맺는 것을 말한다. 
SELECT EMPLOYEE_ID, FIRST_NAME, MANAGER_ID
FROM EMPLOYEES;
--
SELECT WORK.FIRST_NAME 사원명, MANAGER.FIRST_NAME 매니저명
FROM EMPLOYEES WORK, EMPLOYEES MANAGER
WHERE WORK.MANAGER_ID = MANAGER.EMPLOYEE_ID;
--사원의 이름과 그의 매니저 이름을 출력하는 쿼리문
SELECT RPAD(WORK.FIRST_NAME, 11,' ') || '의 매니저는 ' || MANAGER.FIRST_NAME || '이다.' AS "그 사원의 매니저"
FROM EMPLOYEES WORK, EMPLOYEES MANAGER
WHERE WORK.MANAGER_ID = MANAGER.EMPLOYEE_ID;
--6) ANSI Join / ANSI(미국표준연구소)SQL은 대부분의 상용 데이터 베이스 시스템에서 표준 언어이다.
--①ANSI Cross Join 이전에는 쉼표로 테이블 명을 구분했으나 쉼표 대신 CROSS JOIN이라고 명확하게 지정
SELECT * FROM EMPLOYEES CROSS JOIN DEPARTMENTS;
--②ANSI Inner Join / 앞서 배운 조인 구문 중 공통 칼럼'='(equal) 비교연산자를 통해 같은 값을 가지는 로우를
--연결하는 형태이나 ANSI Inner Join은 다음과 같은 형식으로 작성
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID;
--
SELECT FIRST_NAME, DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
ON EMPLOYEES.DEPARTMENT_ID = DEPARTMENTS.DEPARTMENT_ID
WHERE FIRST_NAME = 'Susan';
--USING을 이용한 조인 조건 지정
--두 테이블 간의 조인 조건에 사용되는 칼럼이 같다면 ON대신 USING을 사용할 수 있다.
SELECT EMPLOYEES.FIRST_NAME, DEPARTMENTS.DEPARTMENT_NAME
FROM EMPLOYEES INNER JOIN DEPARTMENTS
USING(DEPARTMENT_ID)
WHERE FIRST_NAME = 'Susan';
--④ANSI Outer Join / ANSI 구문의 OUTER JOIN에서는 전체 데이터를 가져올 테이블을 기준으로 LEFT,RIGHT를 설정해주면 된다.
-- 그리고 이전에 지원하지 않았던 FULL까지 지원한다.
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E RIGHT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID;
--
SELECT E.FIRST_NAME, D.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E LEFT OUTER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
WHERE HIRE_DATE >= '2007/01/01' AND HIRE_DATE <= '2007/06/30';
