--2022.11.08
--[오라클] 뷰(VIEW)
--1)뷰의 개념 / 뷰(View)는 한마디로 물리적인 테이블을 근거한 논리적인 가상 테이블이라고 정의할 수 있다.
--뷰는 물리적인 구조인 테이블과는 달리 데이터 저장 공간이 없다. 뷰는 단지 쿼리문을 저장하고 있는 객체라고 표현할 수 있다.
GRANT CREATE VIEW TO hr;

CREATE TABLE EMP_COPY
AS
SELECT * FROM EMPLOYEES;

CREATE VIEW VIEW_EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME,SALARY,DEPARTMENT_ID
FROM EMP_COPY
WHERE DEPARTMENT_ID = 10;
--2)뷰 생성과 조회 / 뷰를 생성하기 위해서는 테이블 생성과 같이 CREATE 문을 사용한다.
DROP TABLE EMP01;
CREATE TABLE EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMPLOYEES;
--
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP01
WHERE DEPARTMENT_ID = 30;
--3)뷰 생성 / 뷰는 테이블처럼 하나의 개체로서 테이블을 생성할 때와 유사하게 CREATE VIEW 명령어로 생성한다
--OR REPLACE VIEW / 새로운 뷰를 만들 수 있을 뿐만 아니라 기존에 뷰가 존재하더라도 삭제하지 않고 새로운 구조의 뷰로
--변경(REPLACE)할 수 있다.
--FORCE / 기본 테이블의 존재 여부에 상관없이 뷰를 생성한다.
--WITH CHECK OPTION / 해당 뷰를 통해서 볼 수 있는 범위 내에서만 UPDATE 또는 INSERT가 가능하다.
CREATE OR REPLACE VIEW VIEW_EMP01
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP01
WHERE DEPARTMENT_ID = 30;
--①뷰에 관련된 데이터 딕셔너리 / USER_VIEWS 에 사용자가 생성한 모든 뷰에 대한 정의가 저장되어 있다.
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;
--②뷰의 동작 원리
--4)뷰의 종류(뷰를 정의하기 위해서 사용되는 기본 테이블의수에 따라 단순 뷰와 복합 뷰로 나뉜다.)
--①단순 뷰에 대한 데이터 조작
SELECT * FROM VIEW_EMP01;
--
INSERT INTO VIEW_EMP01
VALUES(250,'ANGEL',7000,30);

SELECT * FROM VIEW_EMP01;
--
SELECT * FROM EMP01;
--②단순 뷰의 칼럼에 별칭 부여하기
CREATE OR REPLACE VIEW VIEW_EMP02
AS
SELECT EMPLOYEE_ID 사원번호, FIRST_NAME 사원명, SALARY 급여, DEPARTMENT_ID 부서번호
FROM EMP01;

CREATE OR REPLACE VIEW VIEW_EMP02(사원번호, 사원명, 급여, 부서번호)
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP01;

DESC VIEW_EMP02;
--
SELECT * FROM VIEW_EMP02;
--
SELECT * FROM VIEW_EMP02
WHERE 부서번호 = 10;
--
SELECT *
FROM VIEW_EMP02
WHERE DEPARTMENT_ID = 10;
--③그룹 함수를 사용한 단순 뷰 
CREATE OR REPLACE VIEW VIEW_SALARY
AS
SELECT DEPARTMENT_ID, SUM(SALARY) AS "SalarySum", TRUNC(AVG(SALARY)) AS "SalaryAvg"
FROM EMP01
GROUP BY DEPARTMENT_ID
ORDER BY DEPARTMENT_ID;
--
SELECT *
FROM VIEW_SALARY;
--④복합 뷰 / 두 개 이상의 기본 테이블에 의해 정의한 뷰
CREATE VIEW VIEW_EMP_DEPT
AS
SELECT E.EMPLOYEE_ID, E.FIRST_NAME, E.SALARY, E.DEPARTMENT_ID, D.DEPARTMENT_NAME
FROM EMPLOYEES E INNER JOIN DEPARTMENTS D
ON E.DEPARTMENT_ID = D.DEPARTMENT_ID
ORDER BY DEPARTMENT_ID DESC;
--
SELECT * FROM VIEW_EMP_DEPT;
--5)뷰 삭제
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;
--
DROP VIEW VIEW_SALARY;
--
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;
--6)뷰 수정을 위한 OR REPLACE 옵션 / 존재하지 않으면 새로운 뷰 생성, 존재하면 내용 변경
CREATE OR REPLACE VIEW VIEW_EMP03
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP01
WHERE EMPLOYEE_ID = 10;
--
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;
--7) 기본 테이블 없이 뷰를 생성하기 위한 FORCE 옵션 / 기본 테이블이 존재하지 않더라도 뷰를 생성하려면 FORCE 옵션을 추가해야 한다.
CREATE OR REPLACE FORCE VIEW VIEW_NOTABLE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, DEPARTMENT_ID
FROM EMP15
WHERE EMPLOYEE_ID = 10; --경고: 컴파일 오류와 함께 뷰가 생성되었습니다.
--
SELECT VIEW_NAME, TEXT
FROM USER_VIEWS;
--8)WITH CHECK OPTION / 뷰 생성시 조건으로 지정한 칼럼 값을 변경하지 못하도록 하는 것이다.
CREATE OR REPLACE VIEW VIEW_CHK
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP01
WHERE DEPARTMENT_ID = 20 WITH CHECK OPTION;
--
SELECT * FROM VIEW_CHK;
--
UPDATE VIEW_CHK
SET DEPARTMENT_ID = 10 -- 급여가 5000이상인 사원을 10 번 부서로 이동하는 쿼리문
WHERE SALARY >= 5000; --부서번호에 옵션을 지정하였으므로 이 뷰를 통해서는 부서번호를 변경할 수 없다.
--9)WITH READ ONLY / 뷰를 통해서는 기본 태이블의 어떤 컬럼에 대해서도 내용을 절대 변경할 수 없도록 하는 것이다.
CREATE OR REPLACE VIEW VIEW_READ
AS
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY, DEPARTMENT_ID
FROM EMP01
WHERE DEPARTMENT_ID = 30 WITH READ ONLY;
--
UPDATE VIEW_READ
SET DEPARTMENT_ID = 1000;--오류발생
--10) 뷰 활용하기 / ROWNUM 칼럼
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES;
--
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;
--
CREATE OR REPLACE VIEW VIEW_HIRE
AS
SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM EMPLOYEES
ORDER BY HIRE_DATE DESC;
--
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM VIEW_HIRE;
--
SELECT ROWNUM,EMPLOYEE_ID,FIRST_NAME,HIRE_DATE
FROM VIEW_HIRE
WHERE ROWNUM <= 5;
--①인라인 뷰로 TOP-N구하기
SELECT ROWNUM, EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
FROM(SELECT EMPLOYEE_ID, FIRST_NAME, HIRE_DATE
    FROM EMPLOYEES
    ORDER BY HIRE_DATE DESC)
    WHERE ROWNUM <= 5;
--강사님<예제> EMPLOYEES 테이블과 DEPARTMENTS 테이블을 조회하여 
--부서 번호와 부서별 최대 급여 및 부서명을 출력하세요
SELECT E.DEPARTMENT_ID, D.DEPARTMENT_NAME, E.SALARY
FROM(SELECT DEPARTMENT_ID, MAX(SALARY) SALARY
    FROM EMPLOYEES GROUP BY DEPARTMENT_ID) E, DEPARTMENTS D
WHERE E.DEPARTMENT_ID = D.DEPARTMENT_ID;
-- 11)Materialized View (MVIEW) - 구체화 된 뷰
--권한 생성 cmd sys로 했음
CREATE MATERIALIZED VIEW M_EMP
BUILD IMMEDIATE -- 서브쿼리 부분을 수행해서 데이터를 가져오라는 의미. 
REFRESH
ON DEMAND --원본테이블 변경시 동기화 여부 결정. 사용자가 수동으로 동기화명령을 수행해서 설정.
--ON COMMIT 옵션은 원본 테이블에 데이터 변경 후 COMMIT이 발생하면 자동으로 동기화시키라는 의미.
COMPLETE --Mview내의 데이터 전체가 원본 테이블과 동기화 되는 방법.
ENABLE QUERY REWRITE
AS 
SELECT EMPLOYEE_ID, FIRST_NAME, SALARY FROM EMP01;
--수동으로 원본 테이블과 Mview 데이터 동기화 하기
DELETE FROM EMP01 WHERE EMPLOYEE_ID = 250;
--동기화 전에 원본 테이블과 Mview의 데이터 건수를 조회하여 보자.
SELECT COUNT(*) FROM EMP01;
SELECT COUNT(*) FROM M_EMP;
BEGIN
        DBMS_MVIEW.REFRESH('M_EMP');
END;
/
SELECT COUNT(*) FROM M_EMP;
--Mview 조회하기
SELECT MVIEW_NAME, QUERY FROM USER_MVIEWS
WHERE MVIEW_NAME = 'M_EMP';
--Mview 삭제하기
DROP MATERIALIZED VIEW M_EMP;